devtools::install_github("rstudio/shiny")
install.packages("swirl")
library(swirl)
install_from_swirl("R Programming")
swirl()
5+7
install_github("rstudio/leaflet")
updateR()
build_github_devtools()
library(devtools)
build_github_devtools()
install.packages("devtools.zip", repos = NULL, type = "source")
library(devtools)
install.packages("devtools.zip", repos = NULL, type = "source")
q()
install.packages("leaflet")
install.packages(networkD3)
install.packages(c("packrat", "roxygen2", "stringi", "xtable"))
install.packages("networkD3")
library(devtools)
install_github("rstudio/leaflet")
install.packages(rga)
install_github("rga", "skardhamar")
library(rga)
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))<br> rga.open(instance="ga")
ga$getProfiles()
rga.open(instance="ga")
ga$getProfiles()
id <- "56989150"
ga$getRefClass()
myresults <- ga$getData(id, start.date="", end.date="", <br> metrics = "",<br> dimensions = "",<br> sort = "",<br> filters = "",<br> segment = "",<br> start = 1,<br> max = 1000)
myresults <- ga$getData(id, start.date="2015-09-01", end.date="2015-10-30",<br> metrics = "ga:visits",<br> dimensions = "ga:source",<br> sort = "-ga:visits",<br> start = 1, max = 10)
install.packages(c("RCurl", "rjson", "RGoogleAnalytics", "ggplot2", "plyr", "gridExtra", "reshape"))
install.packages(c("RCurl", "rjson", "RGoogleAnalytics", "ggplot2",
install.packages(c("RCurl", "rjson", "RGoogleAnalytics", "ggplot2", "plyr", "gridExtra", "reshape"))
require("RCurl")
require("rjson")
require("ggplot2")
require("plyr")
require("gridExtra")
require("reshape")
require("RGoogleAnalytics")
query <- QueryBuilder()
install.packages("devtools")
library(devtools)
query <- QueryBuilder()
library("swirl")
swirl()
getwd()
file.create("mytest.R")
list.files()
file.exists("mytest.R")
file.info("mytest.R")
file.rename("mytest.R", "mytest2.R")
file.copy("mytest2.R","mytest3.R")
file.path("mytest3.R")
file.path("mytest3.R")$mode
file.path("folder1", "folder2")
?dir.create
dir.create(file.path("testdir2"),"testdir3")
dir.create(file.path("testdir2","testdir3"), recursive = TRUE)
unlink("testdir2",recursive = TRUE)
setwd("just4")
?setwd()
?setwd(getwd())
setwd(getwd())
setwd("C:/Users/just4/testdir")
info()
setwd(old.dir())
setwd(testdir)
setwd("testdir"")
install.packages("roxygen2")
skip()
unlink("testdir", recursive = TRUE)
help unzip()
helpunzip()
?unzip()
swirl(12)
ls()
class(plants)
dim(plants)
nrow(plants)
ncol(plants)
object.size(plants)
names(plants)
head(duration)
head()
?head()
head(1)
head(plants)
head(plants, 10)
tail(plants)
tail(plants,15)
summary(plants)
able(plants$Active_Growth_Period)
table(plants$Active_Growth_Period)
str(plants)
library("swirl")
rm(list=ls())
swirl()
swirl()
library("swirl")
rm(list=ls())
swirl()
info()
main()
main()
sum(flags$orange)
flag_colors <- flags[, 11:17]
head()
head(flag_colors)
lapply(flag_colors,sum)
sapply(flag_colors,sum)
sapply(flag_colors,mean)
flag_shapes <- flags[, 19:23]
lapply(range(flag_shapes))
lapply(flag_shapes)
?lapply
lapply(,range(flag_shapes))
range(flag_shapes)
lapply(flag_shapes, range)
shape_mat <- sapply(flag_shapes, range)
shape_mat
class(shape_mat)
unique(c(3, 4, 5, 5, 5, 6, 6))
unique_vals <- lapply(flags,unique(c())
install.packages("roxygen2")
install.packages("roxygen2")
unique_vals <- lapply(flags,unique)
unique_vals
length(unique_vals)
sapply(unique_vals, length)
sapply(unique_vals,unique)
info()
play()
nxt()
sapply(unique_vals(,1),unique)
sapply(unique_vals(,cols),unique)
sapply(unique_vals,unique)
sapply(flags, unique)
lapply(unique_vals, function(elem) elem[2])
TRUE==TRUE
FALSE==TRUE==FALSE
(FALSE==TRUE)==FALSE
6==7
6<7
10<=10
5!=7
5!=7
5!==7
5==7
!5==7
FALSE&FALSE
TRUE & c(TRUE, FALSE, FALSE)
TRUE && c(TRUE, FALSE, FALSE)
TRUE | c(TRUE, FALSE, FALSE)
TRUE || c(TRUE, FALSE, FALSE)
5 > 8 || 6 != 8 && 4 > 3.9
isTRUE(6 > 4)
identical('twins', 'twins')
xor(5 == 6, !FALSE)
ints <- sample(10)
ints
ints>5
which(ints>7)
any(ints<0)
all((ints>0))
all(ints>0)
exit
exit()
?inverse
?inverse
?solved
?solve
?inverse
## cachematrix.R
##
## Create a cache marix object that can be used to
## repeatably solve the inverse of the marix, but only
## calculate the inverse once.
##
## Usage:
##  M <- matrix(c(1, 2, 3, 4), nrow=2, ncol=2)
##  cacheMatrix <- makeCacheMatrix(M)
##  cacheSolve(cacheMatrix)
##
##  cacheMatrix$set(M)      # Change the matrix being cached.
##  M <- cacheMatrix$get()  # Returns the matrix being cached.
##
##  cacheMatrix$setInverse(solve(data, ...)) # Private function containing cached inverse of x
##  cacheMatrix$getInverse()                 # Private function used to get the cached inverse of x
## Create a cacheMatrix object for an invertale matrix
makeCacheMatrix <- function(original.matrix = matrix()) {
cached_inverse <- NULL
set <- function(y) {
original.matrix <<- y
cached_inverse <<- NULL
}
get <- function() Original.Matrix
setInverse <- function(inverse) cached_inverse <<- inverse
getInverse <- function() cached_inverse
list(
set = set,
get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## Return the inverse of an cacheMatrix object
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
invFunc <- x$getInverse()
if(!is.null(invFunc)) {
message("getting cached data")
return(invFunc)
}
data <- x$get()
invFunc <- solve(data, ...)
x$setInverse(invFunc)
invFunc
}
M <- matrix(c(1, 2, 3, 4), nrow=2, ncol=2)
cacheMatrix <- makeCacheMatrix(M)
cacheMatrix()
cacheMatrix
cacheSolve(cache.matrix)
cache.matrix <- makeCacheMatrix(M)
cache.matrix
cacheSolve(cache.matrix)
cache.matrix <- makeCacheMatrix(M)
## cachematrix.R
##
## Create a cache marix object that can be used to
## repeatably solve the inverse of the marix, but only
## calculate the inverse once.
##
## Method to call function:
##  M <- matrix(c(1, 2, 3, 4), nrow=2, ncol=2)
##  cache.matrix <- makeCacheMatrix(M)
##  cacheSolve(cache.matrix)
##
##  cacheMatrix$set(M)      # Change the matrix being cached.
##  M <- cacheMatrix$get()  # Returns the matrix being cached.
##
##  cache.matrix$setInverse(solve(data, ...)) # Function containing inverse of cached matrix
##  cache.matrix$getInverse()                 # Function used to get the inverse of cached matrix
## Create a cacheMatrix object for an invertale matrix
makeCacheMatrix <- function(original.matrix = matrix()) {
cached_inverse <- NULL
set <- function(y) {
original.matrix <<- y
cached_inverse <<- NULL
}
get <- function() original.matrix
# Inversing the matrix using build in inverse() function in R
setInverse <- function(inverse) cached_inverse <<- inverse
getInverse <- function() cached_inverse
list(
set = set,
get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## Return the inverse of a cached.matrix object
cacheSolve <- function(cached.matrix, ...) {
## Return a cached matrix: using the solve function
## to return the inverse of 'cached.matrix'
inverse_matrix <- cached.matrix$getInverse()
if(!is.null(inverse_matrix)) {
message("getting cached matrix")
return(inverse_matrix)
}
data <- cached.matrix$get()
inverse_matrix <- solve(data, ...)
cached.matrix$setInverse(inverse_matrix)
inverse_matrix
}
M <- matrix(c(3, 4, 5, 6), nrow=2, ncol=2)
cache.matrix <- makeCacheMatrix(M)
cacheSolve(cache.matrix)
## Create a cached matrix to solve
## the inverse of the marix, calculate the inverse of the cached matrix
##
## Method to call function:
##  M <- matrix(c(3, 4, 5, 6), nrow=2, ncol=2)
##  cache.matrix <- makeCacheMatrix(M)
##  cacheSolve(cache.matrix)
##
##  cache.matrix$set(M)      # Change the cached matrix
##  M <- cacheMatrix$get()   # Return the cached.matrix
##
##  cache.matrix$setInverse(solve(data, ...)) # Function containing inverse of the cached matrix
##  cache.matrix$getInverse()                 # Function to return the inverse of the cached matrix
## Create an object for an inverted matrix
makeCacheMatrix <- function(original.matrix = matrix()) {
cached_inverse <- NULL
set <- function(y) {
original.matrix <<- y
cached_inverse <<- NULL
}
get <- function() original.matrix
# Inversing the matrix using build in inverse() function in R
setInverse <- function(inverse) cached_inverse <<- inverse
getInverse <- function() cached_inverse
list(
set = set,
get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## Return the inverse of a cached.matrix object
cacheSolve <- function(cached.matrix, ...) {
## Return a cached matrix: using the solve function
## to return the inverse of 'cached.matrix'
inverse_matrix <- cached.matrix$getInverse()
if(!is.null(inverse_matrix)) {
message("getting cached matrix")
return(inverse_matrix)
}
data <- cached.matrix$get()
inverse_matrix <- solve(data, ...)
cached.matrix$setInverse(inverse_matrix)
inverse_matrix
}
## Create a cached matrix to solve
## the inverse of the marix, calculate the inverse of the cached matrix
##
## Method to call function:
##  M <- matrix(c(3, 4, 5, 6), nrow=2, ncol=2)
##  cache.matrix <- makeCacheMatrix(M)
##  cacheSolve(cache.matrix)
##
##  cache.matrix$set(M)      # Change the cached matrix
##  M <- cache.matrix$get()   # Return the cached.matrix
##
##  cache.matrix$setInverse(solve(data, ...)) # Function containing inverse of the cached matrix
##  cache.matrix$getInverse()                 # Function to return the inverse of the cached matrix
## Create an object for an inverted matrix
makeCacheMatrix <- function(original.matrix = matrix()) {
cached_inverse <- NULL
set <- function(y) {
original.matrix <<- y
cached_inverse <<- NULL
}
get <- function() original.matrix
# Inversing the matrix using build in inverse() function in R
setInverse <- function(inverse) cached_inverse <<- inverse
getInverse <- function() cached_inverse
list(
set = set,
get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## Return the inverse of a cached.matrix object
cacheSolve <- function(cached.matrix, ...) {
## Return a cached matrix: using the solve function
## to return the inverse of 'cached.matrix'
inverse_matrix <- cached.matrix$getInverse()
if(!is.null(inverse_matrix)) {
message("getting cached matrix")
return(inverse_matrix)
}
data <- cached.matrix$get()
inverse_matrix <- solve(data, ...)
cached.matrix$setInverse(inverse_matrix)
inverse_matrix
}
M <- matrix(c(3, 4, 5, 6), nrow=2, ncol=2)
cache.matrix <- makeCacheMatrix(M)
cacheSolve(cache.matrix)
cache.matrix$set(M)
M <- cache.matrix$get()
M
source('~/datasciencecoursera/R-Programming Assignment 2/cachematrix.R')
## Create a cached matrix to solve
## the inverse of the marix, return the inverse of the cached matrix
##
## Method to call function:
##  M <- matrix(c(3, 4, 5, 6), nrow=2, ncol=2)
##  cache.matrix <- makeCacheMatrix(M)
##  cacheSolve(cache.matrix)
## Create an object for an inverted matrix
makeCacheMatrix <- function(original.matrix = matrix()) {
cached_inverse <- NULL
set <- function(y) {
original.matrix <<- y
cached_inverse <<- NULL
}
get <- function() original.matrix
# Inversing the matrix using build in inverse() function in R
setInverse <- function(inverse) cached_inverse <<- inverse
getInverse <- function() cached_inverse
list(
set = set,
get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## Return the inverse of a cached.matrix object
cacheSolve <- function(cached.matrix, ...) {
## Return a cached matrix: using the solve function
## to return the inverse of 'cached.matrix'
inverse_matrix <- cached.matrix$getInverse()
if(!is.null(inverse_matrix)) {
message("getting cached matrix")
return(inverse_matrix)
}
data <- cached.matrix$get()
inverse_matrix <- solve(data, ...)
# Function to inverse cached matrix
cached.matrix$setInverse(inverse_matrix)
inverse_matrix
}
M <- matrix(c(3, 4, 5, 6), nrow=2, ncol=2)
M
cache.matrix <- makeCacheMatrix(M)
M$get()
cach.matrix
cache.matrix
cacheSolve(cache.matrix)
install.packages(c("curl", "git2r", "jsonlite", "lubridate"))
install.packages(c("ggplot2", "git2r", "raster", "rstudioapi"))
url <- https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv
url <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv""
library("plyr", lib.loc="~/R/win-library/3.2")
detach("package:plyr", unload=TRUE)
install.packages("rvest")
url <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv"
f <- file.path(getwd(), "ss06hid.csv")
download.file(url, f)
dt <- data.table(read.csv(f))
agricultureLogical <- dt$ACR == 3 & dt$AGS == 6
which(agricultureLogical)[1:3]
f <- file.path(getwd(), "ss06hid.csv")
dt <- data.table(read.csv(f))
f
dt <- data.table(read.csv(f))
source('~/datasciencecoursera/Getting And Cleaning Data/run_analysis.R')
}
source('~/datasciencecoursera/Getting And Cleaning Data/run_analysis.R')
source('~/datasciencecoursera/Getting And Cleaning Data/run_analysis.R')
combinedData
source('~/datasciencecoursera/Getting And Cleaning Data/run_analysis.R')
View(run_analysis)
load_data <- function(type, directory, meanCols, stdCols) {
run_analysis()
load_data <- function(type, directory, meanCols, stdCols) {
load_data <- function(type, directory, meanCols, stdCols) {
subject <- read.table(sprintf("%s/%s/subject_%2$s.txt", directory, type))
source('~/datasciencecoursera/Getting And Cleaning Data/run_analysis.R')
source('~/datasciencecoursera/Getting And Cleaning Data/run_analysis.R')
source('~/datasciencecoursera/Getting And Cleaning Data/run_analysis2.R')
source('~/datasciencecoursera/Getting And Cleaning Data/run_analysis.R')
source('~/datasciencecoursera/Getting And Cleaning Data/UCI HAR Dataset/run_analysis.R')
setwd("~/datasciencecoursera/Getting And Cleaning Data/UCI HAR Dataset")
write.table(result, "data_set_with_the_averages.txt")
setwd("~/datasciencecoursera/Getting And Cleaning Data/UCI HAR Dataset")
source('~/datasciencecoursera/Getting And Cleaning Data/UCI HAR Dataset/run_analysis.R')
Use data <- read.table("data_set_with_the_averages.txt")
data <- read.table("data_set_with_the_averages.txt")
data
swirl()
library("swirl", lib.loc="~/R/win-library/3.2")
swirl()
install_from_swirl("Getting and Cleaning Data")
swirl()
mydf <- read.csv(path2csv, stringsAsFactors = FALSE)
dim(mydf)
head()
head(mydf)
library(dplyr)
packageVersion("dplyr")
cran <- tbl_df(mydf)
rm("mydf")
cran
?select
select(cran, ip_id, package, country)
5:20
select(cran, r_arch:country)
select(cran, country:r_arch)
select(cran)
info()
skip()
select(cran, -time)
-5:20
skip()
select(-x:size)
skip()
filter(cran, package == "swirl")
filter(cran,r_version == "3.1.1", country == "US")
skip()
filter(cran,r_version == "3.0.2", country == "US")
filter(cran,r_version == "3.0.2", country == "IN")
filter(cran,r_version <= "3.0.2", country == "IN")
filter(cran, country == "US" | country == "IN")
skip()
is.na(c(3, 5, NA, 10))
!is.na(c(3, 5, NA, 10))
filter(cran,r_version !is.na(c(NA)))
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
exit
